<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-110000</depth>
  <persistent>0</persistent>
  <parentName>FauxCPHUD</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
The Arena game mode consists of multiple rounds. Each round starts with a fixed-time setup period where
players can spawn and change their team and class. This is followed by the round proper, which is won
by the first team to either eliminate the enemy team or gain control of the ArenaCP, which unlocks a
fixed time into the round proper.
When a winner is decided, there is a fixed-time round end period where the current score is shown and
where humiliation for the losing team is in effect (if any of them survive).
If not enough players are present (at least one on each team), the game mode goes into a waitingForPlayers
state after roundEnd, which transitions to roundSetup once enough players are present again.
An Arena map can end in one of two ways: Either by one team winning $caplimit rounds, or by the map timer
running down to 0. In either case the map end is only induced after a roundEnd, so a running round will always
be allowed to finish. However, if the timer runs out in the "waitingForPlayers" state, the map ends immediately.
        
Notes:
SetupGates do not unlock after the setup period, they unlock together with the CP. For this reason,
Arena maps don't use setup gates around the spawn area.
*/

ARENA_STATE_WAITING = 0;
ARENA_STATE_ROUND_SETUP = 1;
ARENA_STATE_ROUND_PROPER = 2;
ARENA_STATE_ROUND_END = 3;

timeLimit = global.timeLimitMins*30*60;
timer = timeLimit;
winners = TEAM_SPECTATOR;
redWins = 0;
blueWins = 0;
endCount = 0;
roundStart = 0;
cpUnlock = 1800;
overtime = 0;
redteamCharacters = 0;
blueteamCharacters = 0;
state = ARENA_STATE_WAITING;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>redteam = 0;
blueteam = 0;
redteamCharacters = 0;
blueteamCharacters = 0;

for(i = 0; i &lt; ds_list_size(global.players); i += 1)
{
    player = ds_list_find_value(global.players, i);
    if(player.team == TEAM_RED)
    {
        redteam += 1;
        if (player.object != -1 or alarm[5] != -1)
            redteamCharacters += 1;
    }
    else if (player.team == TEAM_BLUE)
    {
        blueteam += 1;
        if (player.object != -1 or alarm[5] != -1)
            blueteamCharacters += 1;    
    }
}

if (global.run_virtual_ticks)
{
    if(state != ARENA_STATE_ROUND_SETUP and cpUnlock &gt; 0)
    {
        cpUnlock -= 1;
        
        if (global.isHost)
        {
            if (cpUnlock &lt;= 0)
            {
                sendEventUnlockCP();
                doEventUnlockCP();
            }
            else if (cpUnlock == 150)
                GameServer.syncTimer = 1;
        }
    }
    
    if(state == ARENA_STATE_ROUND_SETUP and roundStart &gt; 0)
        roundStart -= 1;
    
    if(state == ARENA_STATE_ROUND_END and endCount &gt; 0)
        endCount -= 1;
        
    if (timer &gt; 0)
        timer -= 1;
    
    if ((state == ARENA_STATE_ROUND_SETUP or state == ARENA_STATE_ROUND_PROPER) and timer &lt;= 0)
        overtime = 1;
    
    if (global.isHost)
    {
        if(global.winners != -1)
        {
            // Essentially an extra "end of map" state
        }
        if(state == ARENA_STATE_WAITING)
        {
            if(timer &lt;= 0)
                global.winners = TEAM_SPECTATOR;
            else if(redteam &gt;= 1 and blueteam &gt;= 1)
                serverArenaRestart();
        }
        else if (state == ARENA_STATE_ROUND_SETUP)
        {
            if (roundStart &lt;= 0)
            {
                sendEventArenaStartRound();
                doEventArenaStartRound();
            }
        }
        else if (state == ARENA_STATE_ROUND_PROPER)
        {
            var win;
            win = -1;
            if (ArenaControlPoint.team != -1)
                win = ArenaControlPoint.team;
            else if (blueteamCharacters == 0)
                win = TEAM_RED;
            else if (redteamCharacters == 0)
                win = TEAM_BLUE;
                
            if(win != -1)
                serverArenaEndRound(win);
        }
        else if (state == ARENA_STATE_ROUND_END)
        {
            if (endCount &lt;= 0)
            {
                if (redWins &gt;= global.caplimit)
                    global.winners = TEAM_RED;
                else if (blueWins &gt;= global.caplimit)
                    global.winners = TEAM_BLUE;
                else if (timer &lt;= 0)
                    global.winners = TEAM_SPECTATOR;
                else if (redteam == 0 or blueteam == 0)
                {
                    sendEventArenaWaitForPlayers();
                    doEventArenaWaitForPlayers();
                }
                else
                    serverArenaRestart();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.updateType == FULL_UPDATE)
{
    receiveCompleteMessage(global.serverSocket, 6, global.deserializeBuffer);
    redWins = read_ubyte(global.deserializeBuffer);
    blueWins = read_ubyte(global.deserializeBuffer);
    state = read_ubyte(global.deserializeBuffer);
    winners = read_byte(global.deserializeBuffer);
    endCount = read_ushort(global.deserializeBuffer);
}

receiveCompleteMessage(global.serverSocket, 8, global.deserializeBuffer);
global.timeLimitMins = read_ubyte(global.deserializeBuffer);
timeLimit = global.timeLimitMins*30*60;
timer = read_uint(global.deserializeBuffer);
cpUnlock = read_ushort(global.deserializeBuffer);
ArenaControlPoint.locked = cpUnlock &gt; 0;
roundStart = read_ubyte(global.deserializeBuffer)*2;
with (ArenaControlPoint) event_user(13);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.updateType == FULL_UPDATE)
{
    write_ubyte(global.serializeBuffer, redWins);
    write_ubyte(global.serializeBuffer, blueWins);
    write_ubyte(global.serializeBuffer, state);
    write_byte(global.serializeBuffer, winners);
    write_ushort(global.serializeBuffer, endCount);
}

write_ubyte(global.serializeBuffer, global.timeLimitMins);
write_uint(global.serializeBuffer, timer);
write_ushort(global.serializeBuffer, cpUnlock);
write_ubyte(global.serializeBuffer, floor(roundStart/2));
with (ArenaControlPoint) event_user(12);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>xoffset = view_xview[0];
yoffset = view_yview[0];
xsize = view_wview[0];
ysize = view_hview[0];

if instance_exists(WinBanner) with WinBanner instance_destroy();

global.totalControlPoints = 1;
global.cp[0] = ArenaControlPoint.id;
drawControlPointStatus(cpUnlock);

xshift = -320*global.timerPos;
yshift = 5*global.timerPos;

draw_roundtimer(xoffset, yoffset, xsize, ysize, timer);

draw_set_halign(fa_center); 
if (state == ARENA_STATE_ROUND_SETUP)
{
    draw_text(xoffset+xsize/2, yoffset+ysize/2 + 100, "Game will start in "+string(ceil(roundStart/30))+" seconds");
}

if (state == ARENA_STATE_WAITING)
{
    draw_text(xoffset+xsize/2, yoffset+ysize/2 + 100, "Waiting for players...");
}

if (global.myself != -1)
{
    if (global.myself.object == -1 and state == ARENA_STATE_ROUND_PROPER
        and !overtime and global.winners == -1 and !instance_exists(DeathCam)
        and global.myself.team != TEAM_SPECTATOR)
        draw_text(xoffset+xsize/2, yoffset+ysize/2 + 100, "You will spawn when the next round starts");
    
    //Alive players remaining 
    draw_set_color(c_black);
    draw_sprite_ext(ArenaPlayerCountS, 0, xoffset+xsize/2, yoffset+71, 2, 2, 0, c_white, 1);
    draw_text(xoffset+xsize/2+15, yoffset+73, redteamCharacters);
    draw_sprite_ext(ArenaPlayerCountS, 1, xoffset+xsize/2, yoffset+104, 2, 2, 0, c_white, 1);
    draw_text(xoffset+xsize/2+15, yoffset+106, blueteamCharacters);
}
 
//MVPs
if (state == ARENA_STATE_ROUND_END and global.winners == -1 and !instance_exists(ScoreTableController))
{
    with (DeathCam) instance_destroy();
    
    draw_set_alpha(1);
    draw_set_halign(fa_left);
    draw_set_color(c_white);

    // Note: There is always a winner on round end. If that changes, this code needs to adapt
    var mvpSubimg, mvpTeam;
    if (winners == TEAM_RED)
    {
        if (endCount &gt; 150)
        {
            mvpSubimg = 0;
            mvpTeam = TEAM_RED;
        }
        else
        {
            mvpSubimg = 1;
            mvpTeam = TEAM_BLUE;        
        }
    }
    else
    {
        if (endCount &gt; 150)
        {
            mvpSubimg = 2;
            mvpTeam = TEAM_BLUE;
        }
        else
        {
            mvpSubimg = 3;
            mvpTeam = TEAM_RED;
        }
    }

    draw_sprite_ext(MVPBannerS, mvpSubimg, xoffset+xsize/2, yoffset+ysize/2, 2, 2, 0, c_white, 0.8);
    
    if(variable_local_exists(id, "mvps"))
    {
        // The mvps don't exist for players who join during round end, since syncing them in the FULL_UPDATE
        // would make things more complicated, and it should happen rarely enough that seeing an empty
        // MVP board won't be too annoying.
        
        var mvpXOffset, i;
        mvpXOffset = xoffset+xsize/2;
        for (i=0; i &lt; mvps[mvpTeam]; i+=1)
        {
            var mvpYOffset;
            mvpYOffset = yoffset+ysize/2+76 + 15*i;
            draw_text(mvpXOffset-250, mvpYOffset, mvpName  [mvpTeam,i]);
            draw_text(mvpXOffset- 30, mvpYOffset, mvpKills [mvpTeam,i]);
            draw_text(mvpXOffset+122, mvpYOffset, mvpHealed[mvpTeam,i]);
            draw_text(mvpXOffset+248, mvpYOffset, mvpPoints[mvpTeam,i]);
        }
    }
    
    draw_set_color(make_color_rgb(227, 226, 225));
    draw_set_halign(fa_right);
    draw_text_transformed(xoffset+xsize/2-50, yoffset+ysize/2-90, redWins, 4, 4, 0);
    draw_set_halign(fa_left);
    draw_text_transformed(xoffset+xsize/2+50, yoffset+ysize/2-90, blueWins, 4, 4, 0);

}
 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
