<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>MedigunS</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>Weapon</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    xoffset = -7;
    yoffset = 0;
    refireTime = 3;
    event_inherited();
    
    healTarget = noone;
    healedThisStep = false;
    healAmount = 2/3;
    hphealed = 0;
    maxHealDistance = 300;
    maxMouseSelectDistance = 150; // Heal target selection will favor the character closest to the mouse, as long as it is within this distance of the mouse cursor.
    ubering = false;
    uberCharge=0;
    uberReady=false;
    maxAmmo = 40
    ammoCount = maxAmmo;
    reloadTime = 55;
    reloadBuffer = 0;
    idle=true;
    
    // Threshhold system numbers
    healTierHealth = 125; // HP above which healing is slowed
    healTierAmount = 0.75; // Factor to which healing is slowed (stacks with healing ramp)
    
    if(golden)
    {
        normalSprite = MedigunGoldS;
        recoilSprite = MedigunGoldFS;
        reloadSprite = MedigunGoldFRS;
    }
    else
    {
        normalSprite = MedigunS;
        recoilSprite = MedigunFS;
        reloadSprite = MedigunFRS;
    }
    sprite_index = normalSprite;
        
    //This makes it so that the timer will keep resetting
    //Until Mouse1 is let go
    recoilTime = refireTime+1;
    recoilAnimLength = sprite_get_number(recoilSprite)/2;
    recoilImageSpeed = recoilAnimLength/recoilTime;
    
    reloadAnimLength = sprite_get_number(reloadSprite)/2;
    reloadImageSpeed = reloadAnimLength/reloadTime;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>loopsoundstop(MedigunSnd);
if(instance_exists(healTarget))
    if(healTarget.object != -1)
        healTarget.object.healer = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.particles == PARTICLES_NORMAL)
{
    var shell;
    shell = instance_create(x, y, Shell);
    shell.direction = owner.aimDirection + (100 + random(30)) * image_xscale;
    shell.image_index = 3 + owner.team
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ammoCount = maxAmmo;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>loopsoundstop(UberIdleSnd);</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>loopsoundstop(MedigunSnd);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(uberReady)
{
    if(alarm[4] &lt;= 0)
        loopsoundstart(x,y,UberIdleSnd);
    else
        loopsoundmaintain(x,y,UberIdleSnd);
    
    alarm[4] = 2 / global.delta_factor;
}

if(ubering)
{
    owner.ubered = 1;
    owner.alarm[2] = 3 / global.delta_factor;
    uberCharge -= 25/3 * global.delta_factor;
    if(uberCharge &lt;= 0)
    {
        uberCharge = 0;
        ubering = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!healedThisStep and instance_exists(healTarget))
{
    if(healTarget.object != -1)
        healTarget.object.healer = -1;
            
    healTarget = noone;
}

healedThisStep = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var healTargetId;

receiveCompleteMessage(global.serverSocket, 1, global.deserializeBuffer);
healTargetId = fct_read_ubyte(global.deserializeBuffer);
if(healTargetId != 255) {
    healTarget = ds_list_find_value(global.players, healTargetId);
} else {
    healTarget = noone;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(instance_exists(healTarget))
    fct_write_ubyte(global.serializeBuffer, ds_list_find_index(global.players, healTarget));
else
    fct_write_ubyte(global.serializeBuffer, 255);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    if (readyToShoot and !instance_exists(healTarget) and !ubering and ammoCount &gt; 0)
    {
        ammoCount -= 1;
        playsound(x,y,MedichaingunSnd);
        var shot;
        shot = createShot(x, y + yoffset + 1, Needle, global.DAMAGE_SOURCE_NEEDLEGUN, owner.aimDirection, 7+random(3));
        shot.hitDamage = 4;
        justShot=true;
        with(shot)
            hspeed+=owner.hspeed;
        readyToShoot=false;
        alarm[0] = refireTime / global.delta_factor;
        alarm[5] = (reloadBuffer + reloadTime) / global.delta_factor;
        alarm[7] = alarm[5] / 4;
    }
    else if (uberReady &amp;&amp; (owner.keyState &amp; $10))
    {
        if(global.isHost)
        {
            sendEventUber(ownerPlayer);
            doEventUber(ownerPlayer);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    if(!instance_exists(healTarget) and readyToShoot)
    {
        var bestTarget, bestScore, mouseX, mouseY, aimRayEndX, aimRayEndY;
        bestTarget = noone;
        bestScore = 0;
        
        // Reconstructed mouse position of owner
        mouseX = owner.x + lengthdir_x(owner.aimDistance, owner.aimDirection);
        mouseY = owner.y + lengthdir_y(owner.aimDistance, owner.aimDirection);
        
        // The healer must be aiming at the new heal target to connect. This means
        // the heal target must touch the line from the medigun to the aimRayEnd.
        aimRayEndX = owner.x + lengthdir_x(maxHealDistance, owner.aimDirection);
        aimRayEndY = owner.y + lengthdir_y(maxHealDistance, owner.aimDirection);

        with(Character)
        {
            if(id == other.owner or team != other.owner.team)
                continue;
                
            var healDistance, mouseDistance, targetScore;
            healDistance = point_distance(x, y, other.x, other.y);
            mouseDistance = point_distance(x, y, mouseX, mouseY);
            
            if(healDistance &gt; other.maxHealDistance)
                continue;
                
            if(mouseDistance &lt;= other.maxMouseSelectDistance)
            {
                // Character is in mouse range, so we give it a high score (between 2 and 3). Closer to mouse -&gt; higher score.
                targetScore = 3 - mouseDistance / other.maxMouseSelectDistance; // Mouse distance 0: score 3. Max mouse distance: score 2.
            }
            else
            {
                // Character is not in mouse range, so we give it a low score (between 0 and 1). Closer to healer -&gt; higher score.
                targetScore = 1 - healDistance / other.maxHealDistance; // Heal distance 0: score 1. Heal distance maxHealDistance: score 0.
            }
            
            if(targetScore &lt; bestScore)
                continue;   // We already found a better match
            
            if(!collision_line(other.x, other.y, aimRayEndX, aimRayEndY, id, true, false))
                continue;   // We are not aiming at this character
            
            if(collision_line(other.x, other.y, x, y, Obstacle, true, true))
                continue;   // There is something in the way
            
            bestTarget = player;
            bestScore = targetScore;
        }

        healTarget = bestTarget;
        readyToShoot = false;
        alarm[0] = 1 / global.delta_factor;
    }
    
    if(instance_exists(healTarget)) {
        if(healTarget.object != -1) {
            if(point_distance(x,y,healTarget.object.x, healTarget.object.y)&lt;=maxHealDistance) {
                if(collision_line(x,y, healTarget.object.x, healTarget.object.y, Obstacle, true, true)&lt;0) {
                    healedThisStep = true;
                    
                    if (healTarget.object.healer == -1)
                        healTarget.object.healer = ownerPlayer;
                    if (healTarget.object.burnDuration &gt; 0)
                        healTarget.object.burnDuration -= 1 * global.delta_factor;
                    var healthGained;
                    healthGained = healAmount * calculateHealingFactor(healTarget.object.timeUnscathed);
                    if(healTarget.object.hp &gt; healTierHealth)
                        healthGained *= healTierAmount;
                    healTarget.object.hp = min(healTarget.object.hp + healthGained * global.delta_factor, healTarget.object.maxHp);
                    hphealed += healthGained * global.delta_factor;
                    ownerPlayer.stats[HEALING] += healthGained * global.delta_factor;
                    ownerPlayer.roundStats[HEALING] += healthGained * global.delta_factor;
                    
                    
                    if(ubering == false &amp;&amp; uberCharge&lt;2000){
                        var setup;
                        setup = false;
                        if(instance_exists(ControlPointSetupGate)) {
                            if (areSetupGatesClosed())
                                setup = true;
                        }
                        if(healTarget.object.hp &lt; healTarget.object.maxHp or setup)
                            uberCharge += 2.5 * global.delta_factor;
                        else
                            uberCharge += 1.75 * global.delta_factor;
                        if(uberCharge &gt;= 2000) 
                        {
                            uberCharge = 2000;
                            if(global.isHost)
                            {
                                sendEventUberReady(ownerPlayer);
                                doEventUberReady(ownerPlayer);
                            }
                        }
                    } else if(ubering == true){
                        if healTarget.object.ubered == 0 playsound(x,y,UberStartSnd);
                        healTarget.object.ubered = 1;
                        healTarget.object.alarm[2] = 3 / global.delta_factor; 
                    }
                                                               
                    if hphealed &gt;= HP_PER_POINT {
                        ownerPlayer.stats[POINTS] += 1;
                        ownerPlayer.roundStats[POINTS] += 1;
                        hphealed -= HP_PER_POINT;
                    }

                    if(alarm[3] &lt;= 0) {
                        loopsoundstart(x,y,MedigunSnd);
                    } else {
                        loopsoundmaintain(x,y,MedigunSnd);
                    }
                    alarm[3] = 2 / global.delta_factor;
                } else {
                    healTarget.object.healer = -1;
                    healTarget = noone;
                }
            } else {
                healTarget.object.healer = -1;
                healTarget = noone;
            }
        } else {
            healTarget = noone;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(owner.taunting)
    exit;
    
var imageOffset, xdrawpos, ydrawpos;
imageOffset = owner.team;
xdrawpos = round(x+xoffset*image_xscale);
ydrawpos = round(y+yoffset);
if(instance_exists(healTarget))
{
    if(healTarget.object != -1)
    {
        var color;
        if(healTarget.team == TEAM_RED)
            color = c_red;
        else
            color = c_blue;
            
        draw_set_alpha(0.3);
        draw_line_width_color(xdrawpos+lengthdir_x(24,owner.aimDirection),ydrawpos+lengthdir_y(24,owner.aimDirection),healTarget.object.x, healTarget.object.y, 5, color, color);

        sprite_index = normalSprite;
        imageOffset = owner.team+2;
    }
} else {
    var recoilAlarmStart, reloadAlarmStart;
    recoilAlarmStart = round(recoilTime / global.delta_factor);
    reloadAlarmStart = round(reloadTime / global.delta_factor);
            
    if(alarm[6] &gt; 0) {
        // We are shooting, loop the shoot animation
        sprite_index = recoilSprite;
        imageOffset = floor(recoilAnimLength*(recoilAlarmStart-alarm[6])/recoilAlarmStart) + owner.team*recoilAnimLength;
    } else if (alarm[5] &gt; 0 &amp;&amp; alarm[5] &lt;= reloadAlarmStart) {
        sprite_index = reloadSprite;
        imageOffset = floor(reloadAnimLength*(reloadAlarmStart-alarm[5])/reloadAlarmStart) + owner.team*reloadAnimLength;;
    } else {
        // set the sprite to idle
        sprite_index = normalSprite;
        imageOffset = owner.team;
    }
}


if !owner.player.humiliated draw_sprite_ext(sprite_index,imageOffset, xdrawpos, ydrawpos, image_xscale, image_yscale, image_angle, c_white, 1);
if (owner.ubered) {
    if owner.team == TEAM_RED
        ubercolour = c_red;
    else if owner.team == TEAM_BLUE
        ubercolour = c_blue;
    draw_sprite_ext(sprite_index,imageOffset,round(x+xoffset*image_xscale),round(y+yoffset),image_xscale,image_yscale,image_angle,ubercolour,0.7*image_alpha);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
