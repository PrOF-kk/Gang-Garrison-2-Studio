<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>virtualitem = -1;
xbegin = 112;
ybegin = 152;
spacing = 40;
width = 440; 
items = 10;
offset = 0;

servers = ds_list_create();

numServers = -1;
serversRead = 0;
serverInfoLength = -1;

lobbysocket = fct_tcp_connect(LOBBY_SERVER_HOST, LOBBY_SERVER_PORT);
fct_set_little_endian(lobbysocket, false);

// List protocol ID
parseUuid("297d0df4-430c-bf61-640a-640897eaef57", lobbysocket);

// Send Lobby UUID (big endian)
fct_write_buffer(lobbysocket, global.gg2lobbyId);

fct_socket_send(lobbysocket);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with(Server) {
    instance_destroy();
}

fct_socket_destroy(lobbysocket);
ds_list_destroy(servers);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    var size, namelength, server;
    
    if(lobbysocket != -1) {
        if(fct_socket_has_error(lobbysocket)) {
            if(numServers == -1) {
                show_message("Connecting to the lobby server has failed. Reason:#" + fct_socket_error(lobbysocket));
            }
            fct_socket_destroy(lobbysocket);
            lobbysocket = -1;
        } else if(numServers == -1) {
            if(fct_tcp_receive(lobbysocket, 4)) {
                numServers = fct_read_uint(lobbysocket);
            }
        } else if(serversRead &lt; numServers) {
            if(serverInfoLength == -1) {
                if(fct_tcp_receive(lobbysocket, 4)) {
                    serverInfoLength = fct_read_uint(lobbysocket);
                    if(serverInfoLength&gt;100000)
                    {
                        show_message("Server data block from lobby is too large ("+string(serverInfoLength)+")");
                        serverInfoLength = -1;
                        fct_socket_destroy(lobbysocket);
                        lobbysocket = -1;
                    }
                }
            }
            if(serverInfoLength != -1)
            {
                if(fct_tcp_receive(lobbysocket, serverInfoLength))
                {
                    var infolen, playercount, sameProtocolId;
                    sameProtocolId = false;
                    server = instance_create(0,0,Server);
                    server.protocol = fct_read_ubyte(lobbysocket);
                    server.port = fct_read_ushort(lobbysocket);
                    server.ip = string(fct_read_ubyte(lobbysocket))+"."+string(fct_read_ubyte(lobbysocket))+"."+string(fct_read_ubyte(lobbysocket))+"."+string(fct_read_ubyte(lobbysocket));
                    fct_read_string(lobbysocket, 2+16);
                    server.slots = fct_read_ushort(lobbysocket);
                    server.players = fct_read_ushort(lobbysocket);
                    server.bots = fct_read_ushort(lobbysocket);
                    server.private = ((fct_read_ushort(lobbysocket)&amp;1) != 0);
                    infolen = fct_read_ushort(lobbysocket);
                    repeat(infolen)
                    {
                        var key, val;
                        key = fct_read_string(lobbysocket, fct_read_ubyte(lobbysocket));
                        if(key=="protocol_id")
                        {
                            fct_buffer_set_readpos(global.protocolUuid, 0);
                            sameProtocolId = true;
                            repeat(fct_read_ushort(lobbysocket))
                                if(fct_read_ubyte(global.protocolUuid) != fct_read_ubyte(lobbysocket))
                                    sameProtocolId = false;
                        }
                        else
                        {
                            val = fct_read_string(lobbysocket, fct_read_ushort(lobbysocket));
                            ds_map_add(server.infos, key, val);
                        }
                    }
                    server.compatible = (server.protocol==0 and server.port&gt;0 and sameProtocolId);
                    if(server.bots)
                        playercount = string(server.players) + "+" + string(server.bots);
                    else 
                        playercount = string(server.players);
                    server.playerstring =  playercount + "/" + string(server.slots);
                    
                    server.shortgame = "";
                    if(ds_map_exists(server.infos, "game_short"))
                        server.shortgame = ds_map_find_value(server.infos, "game_short");
                    else if(ds_map_exists(server.infos, "game"))
                        server.shortgame = ds_map_find_value(server.infos, "game");
                    if(server.shortgame != "")
                    {
                        if(ds_map_exists(server.infos, "game_ver"))
                            server.shortgame += " " + ds_map_find_value(server.infos, "game_ver");
                    }
                    server.name = ds_map_find_value(server.infos, "name");
                    serversRead += 1;
                    serverInfoLength = -1;
                }
            }
        } else {
            fct_socket_destroy(lobbysocket);
            lobbysocket = -1;
        }                    
    }
    
    if(mouse_x &gt; xbegin and mouse_x &lt; xbegin+width) {
        virtualitem = round((mouse_y-ybegin+12)/spacing-0.5);
        if(virtualitem&lt;0 or virtualitem&gt;items) {
            virtualitem = -1;
        } else {
            virtualitem += offset;
        }
        if(mouse_check_button_pressed(mb_left) and virtualitem&lt;ds_list_size(servers) and virtualitem&gt;=0){
            server = ds_list_find_value(servers, virtualitem);
            if(server.compatible)
            {            
                global.isHost = false;
                global.serverIP = server.ip;
                global.serverPort = server.port;
                if(instance_exists(Client))
                {   // We can't _actually_ destroy and recreate the Client here, because destroying it will cause a room change and that will cause the Create event not to run... Yay, GM!
                    with(Client)
                    {
                        event_perform(ev_destroy,0);
                        ClientCreate();
                    }
                }
                else
                {
                    instance_create(0,0,Client);
                }
                Client.returnRoom = Lobby;
            }
            else
            {
                var question;
                question = "The selected game is not compatible with this client.##";
                question += "Server: " + sanitiseNewlines(ds_map_find_value(server.infos, "name")) + "#";
                if(ds_map_exists(server.infos, "game"))
                    question += "Game/Mod: " + sanitiseNewlines(ds_map_find_value(server.infos, "game")) + "#";
                if(ds_map_exists(server.infos, "game_ver"))
                    question += "Version: " + sanitiseNewlines(ds_map_find_value(server.infos, "game_ver")) + "#";
                if(ds_map_exists(server.infos, "game_url"))
                {
                    var gameurl, reallyvisit;
                    gameurl = sanitiseNewlines(ds_map_find_value(server.infos, "game_url"));
                    question += "Website: " + gameurl + "##Do you want to visit this website now?";
                    if(show_question(question))
                        if(show_question("Warning: The website link is provided by the game server you selected and could lead anywhere.#Really visit '"+gameurl+"'?"))
                            url_open(ds_map_find_value(server.infos, "game_url"));
                }
                else
                {
                    show_message(question);
                }
            }
        }
    } else {
        virtualitem = -1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, server;
draw_set_color(c_black);
draw_set_alpha(0.5);

draw_pinched_blackrect(xbegin-8, ybegin-16, width+32, 408, 4, 3);
draw_pinched_blackrect(xbegin-8, ybegin-48, 192, 24, 4, false);

draw_set_alpha(1);
draw_set_color(c_white);
draw_set_valign(fa_top);

/* Let the user know the servers are loading */
if (lobbysocket != -1)
    headerstring = "Loading...";
else
    headerstring = "Servers ("+string(ds_list_size(servers))+"/"+string(numServers)+") ";

draw_text(xbegin, ybegin-41, headerstring);

for(i=offset; i&lt;ds_list_size(servers) and i&lt;offset+items; i+=1)
{
    var pixeloffset;
    pixeloffset = spacing*(i-offset)-3;
    server = ds_list_find_value(servers, i);
    
    draw_set_color(c_black);
    draw_set_alpha(0.5);
    draw_pinched_blackrect(xbegin, ybegin+pixeloffset-5, width, 32, 4, 1);
    
    draw_set_alpha(1);
    if(i==virtualitem) {
        draw_set_color(c_red);
    } else if(server.compatible) {
        draw_set_color(c_white);
    } else {
        draw_set_color(c_gray);
    }
    
    draw_set_halign(fa_left);
    if(server.private)
        draw_sprite(ControlPointLockS,0,xbegin,ybegin+pixeloffset+5);
    draw_text(xbegin+10, ybegin+pixeloffset,"["+sanitiseNewlines(server.playerstring)+"]");
    draw_text(xbegin+95, ybegin+pixeloffset,sanitiseNewlines(server.name));
    if(ds_map_exists(server.infos, "map"))
        draw_text(xbegin+95,  ybegin+pixeloffset,'#'+sanitiseNewlines(ds_map_find_value(server.infos, "map")));
    
    draw_set_halign(fa_right);
    draw_text(xbegin+425, ybegin+pixeloffset,sanitiseNewlines(server.shortgame));
    
    /* Draw latency and color indicators */
    if(server.pingFinished) {
        docol = c_red;
        showping = string(server.ping);
        if (server.ping &lt; 275) {
            docol = c_yellow;
        }
        if (server.ping &lt; 135) {
            docol = c_green;
        }
        if (server.ping == -1) {
            docol = c_gray;
            showping = "TIMEOUT";
        }

        draw_text_color(xbegin+425, ybegin+pixeloffset,"#"+showping,docol,docol,docol,docol,1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
