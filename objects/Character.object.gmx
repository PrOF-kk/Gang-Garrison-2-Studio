<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    player = global.paramPlayer;
    team = player.team;
    
    left_bound_offset = sprite_get_bbox_left(sprite_index)-sprite_get_xoffset(sprite_index);
    right_bound_offset = sprite_get_bbox_right(sprite_index)-sprite_get_xoffset(sprite_index);
    top_bound_offset = sprite_get_bbox_top(sprite_index)-sprite_get_yoffset(sprite_index);
    bottom_bound_offset = sprite_get_bbox_bottom(sprite_index)-sprite_get_yoffset(sprite_index);
    
    // Default properties of Characters (those where defaults make sense)
    canDoublejump = 0;
    canCloak = 0;
    canBuild = 0;
    baseJumpStrength = 8+(0.6/2); // reduce the part of the initial frame of gravity that we don't apply anymore (not framerate dependent, meant to match old 30fps arc)
    jumpStrength = baseJumpStrength;
    capStrength = 1;
    
    // for true framerate-independent jumping arcs
    applied_gravity = 0;
    
    // 
    hp = maxHp;
    flamecount = 0;
    invisible = false;
    intel = false;
    taunting = false;
    doublejumpUsed = 0;
    ubered = 0;
    stabbing = 0;
    onCabinet = 0;
    wantToJump = false;
    timeUnscathed = 0;
    syncWrongness = 0;
    
    // animation state
    equipmentOffset = 0;
    onground = true;
    still = true;
    yoffset = 0;
    sprite_special = global.xmas;
    
    // class sprite vars
    if(player.class == CLASS_QUOTE)
    {
        spriteRun = sprite_index;
        spriteJump = sprite_index;
        spriteStand = sprite_index;
        spriteLeanR = sprite_index;
        spriteLeanL = sprite_index;
        spriteIntel = sprite_index; // it's an underlay
    }
    else
    {
        spriteRun = getCharacterSpriteId(player.class, player.team, "Run");
        spriteJump = getCharacterSpriteId(player.class, player.team, "Jump");
        spriteStand = getCharacterSpriteId(player.class, player.team, "Stand");
        spriteLeanR = getCharacterSpriteId(player.class, player.team, "LeanR");
        spriteLeanL = getCharacterSpriteId(player.class, player.team, "LeanL");
        spriteIntel = getCharacterSpriteId(player.class, player.team, "Intel");
    }

    spriteDead = getCharacterSpriteId(player.class, player.team, "Dead");
    humiliationPoses = getCharacterSpriteId(player.class, player.team, "H");
    tauntsprite = getCharacterSpriteId(player.class, player.team, "Taunt");
    
    //afterburn stuff
    burnIntensity = 0; // "heat"
    legIntensity = 7; // afterburn intensity after which additional intsity additions are halved.
                      // it's called a "leg" becauase of a similar concept in dynamic range compression.
    maxIntensity = 13; //maximum afterburn intensity in DPS
    burnDuration = 0; // "fuel"
    maxDuration = 210; //maximum afterburn length in duration ticks (see durationDecay)
    decayDelay = 90; //time between last ignition and intensity lowering
    decayDuration = 90; //time between intensity lowering and zeroing out
    durationDecay = 1; //amount that duration lowers per step
    intensityDecay = burnIntensity / decayDuration;
    burnedBy = -1;
    afterburnSource = -1;
    numFlames = 5 ; //purely cosmetic - the number of flames that someone has with max burnIntensity
    realnumflames = numFlames;
    for(i = 0; i &lt; numFlames; i += 1)
    {
        flameArray_x[i] = random_range(-(right_bound_offset - left_bound_offset)/2, (right_bound_offset - left_bound_offset)/2);
        flameArray_y[i] = random_range(-(bottom_bound_offset - top_bound_offset)/2, (bottom_bound_offset - top_bound_offset)/2);
    }
    alarm[5] = 30 / global.delta_factor; //this alarm re-randomizes the flame positions
    
    // controls
    keyState = 0;
    lastKeyState = 0;
    pressedKeys = 0;
    releasedKeys = 0;
    aimDirection = 0;
    netAimDirection = 0;
    aimDistance = 0;

    image_speed = 0;
    tauntspeed = 3;
    
    animationOffset = CHARACTER_ANIMATION_NORMAL;
    animationImage = 0;
    humiliationOffset = irandom(10)*3; //support for 10 different animations is more than enough
    
    // spinjumping state vars
    _last_xscale = image_xscale;
    spinjumping = false;

    //kill assist/finish off addition
    lastDamageDealer = noone;
    lastDamageSource = -1;
    secondToLastDamageDealer = noone;
    
    bubble = instance_create(0,0,SpeechBubbleO);
    bubble.owner = id;

    afk=false;
    
    // Cloak for Spies
    cloak = false;
    cloakAlpha = 1;
    cloakFlicker = false;

    //healer
    healer = -1;
        
    //canGrabIntel- used for droppan intel
    canGrabIntel = true;
    alarm[1] = 0;
    intelRecharge = 0;
    
    //CP
    cappingPoint = noone;

    //sandvich
    omnomnomnom = false;
    canEat = true;
    eatCooldown = 1350; //45 sec cooldown
    
    //sniper zoom
    zoomed = 0;
    
    //nuts n bolts for contructor
    nutsNBolts = 100;
    maxNutsNBolts = 100;
    
    //jugglin'
    //1 for rocket jump
    //2 for rocket juggle
    //3 for getting air blasted
    //4 for friendly juggles!
    moveStatus = 0;
    
    baseControl = 0.85;
    // warning that baseFriction cannot be equal to 0 nor 1 or div0 will occur
    baseFriction = 1.15;
    controlFactor = baseControl;
    frictionFactor = baseFriction;
    runPower = baseRunPower;
    basemaxspeed = abs(baseRunPower * baseControl / (baseFriction-1));
    highestbasemaxspeed = 9.735; // approximation error &lt; 0.0017 of scout's base max speed

    // used for certain rewards
    stillOverlays = ds_list_create();
    leanROverlays = ds_list_create();
    leanLOverlays = ds_list_create();
    jumpOverlays = ds_list_create();
    runOverlays = ds_list_create();
    walkOverlays = ds_list_create();
    tauntOverlays = ds_list_create();
    crouchOverlays = ds_list_create();
    omnomnomnomOverlays = ds_list_create();
    omnomnomnomSprite = getCharacterSpriteId(CLASS_HEAVY, player.team, "Omnomnomnom");
    demon = -1;
    demonX = 0;
    demonY = 0;
    demonOffset = 0;
    demonDir = 0.5;
    demonFrame = 0;

    gearList = ds_list_create();
    
    // Let's spawn our weapon
    global.paramOwner = id;
    currentWeapon = instance_create(x,y,weapons[0]);
    global.paramOwner = noone;
    
    // Gear that drops with gibs
    has_partyhat     = false;
    has_crown        = false;
    has_navigatorhat = false;

    // Temporary invuln on spawn for deathmatch players
    if(instance_exists(TeamDeathmatchHUD))
    {
        if(player.deathmatch_respawn_bypass != 0)
            deathmatch_invulnerable = player.deathmatch_respawn_bypass;
        else
            deathmatch_invulnerable = global.tdmInvulnerabilityTicks;
        deathmatch_invuln_decay = 0.2; // 5x the normal invuln period when you first spawn
    }
    else
    {
        deathmatch_invulnerable = 0;
        deathmatch_invuln_decay = 0;
    }
    
    // THIS IS A TRUCK LOAD OF GARBAGE CODE THAT SHOULD BE REPLACED ASAP
    
    if(hasClassReward(player, 'Grey_Accessories_') and player.class != CLASS_QUOTE)
    {
        ds_list_add(stillOverlays, global.SilverAttireOverlay[player.class]);
        ds_list_add(leanROverlays, global.SilverAttireLeanROverlay[player.class]);
        ds_list_add(leanLOverlays, global.SilverAttireLeanLOverlay[player.class]);
        ds_list_add(jumpOverlays, global.SilverAttireJumpOverlay[player.class]);
        ds_list_add(runOverlays, global.SilverAttireRunOverlay[player.class]);
        ds_list_add(tauntOverlays, global.SilverAttireTaunt[player.class]);
        if (player.class == CLASS_HEAVY)
        {
            ds_list_add(omnomnomnomOverlays, global.SilverSandwichOverlay[player.class]);
            ds_list_add(walkOverlays, global.SilverAttireOverlay[player.class]);
        }
        if (player.class == CLASS_SNIPER)
            ds_list_add(crouchOverlays, global.SilverAttireOverlay[player.class]);
    }
    else if(hasClassReward(player, 'Gold_Accessories_') and player.class != CLASS_QUOTE)
    {
        ds_list_add(stillOverlays, global.GoldenAttireOverlay[player.class]);
        ds_list_add(leanROverlays, global.GoldenAttireLeanROverlay[player.class]);
        ds_list_add(leanLOverlays, global.GoldenAttireLeanLOverlay[player.class]);
        ds_list_add(jumpOverlays, global.GoldenAttireJumpOverlay[player.class]);
        ds_list_add(runOverlays, global.GoldenAttireRunOverlay[player.class]);
        ds_list_add(tauntOverlays, global.GoldenAttireTaunt[player.class]);
        if (player.class == CLASS_HEAVY)
        {
            ds_list_add(omnomnomnomOverlays, global.GoldenSandwichOverlay[player.class]);
            ds_list_add(walkOverlays, global.GoldenAttireOverlay[player.class]);
        }
        if (player.class == CLASS_SNIPER)
            ds_list_add(crouchOverlays, global.GoldenAttireOverlay[player.class]);
    }
    // You cannot wear more than one hat at once you dingdong
    // 'BH' reward - *B*obble *H*ead - not available for quote
    if(hasClassReward(player, 'BH') and player.class != CLASS_QUOTE)
    {
        // hats use the same sprite for most animations 
        ds_list_add(stillOverlays, global.HatBobbleClassOverlay[player.class]);
        ds_list_add(leanROverlays, global.HatBobbleClassOverlay[player.class]);
        ds_list_add(leanLOverlays, global.HatBobbleClassOverlay[player.class]);
        ds_list_add(jumpOverlays, global.HatBobbleClassOverlay[player.class]);
        ds_list_add(runOverlays, global.HatBobbleClassOverlay[player.class]);
            
        if (player.class == CLASS_HEAVY)
        {
            ds_list_add(walkOverlays, global.HatBobbleClassOverlay[player.class]);
            ds_list_add(omnomnomnomOverlays, global.HatBobbleSandwich[player.class]);
        }
        if (player.class == CLASS_SNIPER)
            ds_list_add(crouchOverlays, global.HatBobbleClassOverlay[player.class]);
            
        if (player.class == CLASS_SPY and player.team == TEAM_BLUE)
        {
            ds_list_add(tauntOverlays, HatBobbleSpyBlueTauntS);
        }
        else
        {
            ds_list_add(tauntOverlays, global.HatBobbleClassTaunt[player.class]);        
        }
    }
    else if(hasClassReward(player, 'TopHatMonocle_'))
    {
        ds_list_add(stillOverlays, global.TopHatMonocleOverlay[player.class]);
        ds_list_add(leanROverlays, global.TopHatMonocleOverlay[player.class]);
        ds_list_add(leanLOverlays, global.TopHatMonocleOverlay[player.class]);
        ds_list_add(jumpOverlays, global.TopHatMonocleOverlay[player.class]);
        ds_list_add(runOverlays, global.TopHatMonocleOverlay[player.class]);
            
        if (player.class == CLASS_HEAVY)
        {
            ds_list_add(walkOverlays, global.TopHatMonocleOverlay[player.class]);
            ds_list_add(omnomnomnomOverlays, global.TopHatMonocleSandwich[player.class]);
        }
        if (player.class == CLASS_SNIPER)
            ds_list_add(crouchOverlays, global.TopHatMonocleOverlay[player.class]);
            
        if (player.class == CLASS_QUOTE and player.team == TEAM_BLUE)
        {
            ds_list_add(tauntOverlays, QuerlyBlueMonocleHatTauntS);
        }
        else
        {
            ds_list_add(tauntOverlays, global.TopHatMonocleTaunt[player.class]);        
        }
    }
    else if(hasClassReward(player, 'TopHat_'))
    {
        ds_list_add(stillOverlays, global.TopHatOverlay[player.class]);
        ds_list_add(leanROverlays, global.TopHatOverlay[player.class]);
        ds_list_add(leanLOverlays, global.TopHatOverlay[player.class]);
        ds_list_add(jumpOverlays, global.TopHatOverlay[player.class]);
        ds_list_add(runOverlays, global.TopHatOverlay[player.class]);
            
        if (player.class == CLASS_HEAVY)
        {
            ds_list_add(walkOverlays, global.TopHatOverlay[player.class]);
            ds_list_add(omnomnomnomOverlays, global.TopHatSandwich[player.class]);
        }
        if (player.class == CLASS_SNIPER)
            ds_list_add(crouchOverlays, global.TopHatOverlay[player.class]);
            
        if (player.class == CLASS_QUOTE and player.team == TEAM_BLUE)
        {
            ds_list_add(tauntOverlays, QuerlyBlueTopHatTauntS);
        }
        else
        {
            ds_list_add(tauntOverlays, global.TopHatTaunt[player.class]);        
        }
    }
    else if (hasReward(player, 'Crown'))
    {
        ds_list_add(gearList, GEAR_CROWN);
        has_crown = true;
    }
    else if (hasReward(player, 'Navigator'))
    {
        ds_list_add(gearList, GEAR_NAVIGATORHAT);
        has_navigatorhat = true;
    }
    else if (global.gg_birthday)
    {
        ds_list_add(gearList, GEAR_PARTY_HAT);
        has_partyhat = true;
    }
    if (hasReward(player, 'WillOWisp'))
    {
        demon = WillOWispS;
    }
    if (hasClassReward(player, 'HaxxyCape_'))
    {
        ds_list_add(gearList, GEAR_HAXXY_CAPE);
    }
    else if (hasClassReward(player, 'RaybannCape_'))
    {
        ds_list_add(gearList, GEAR_RAYBANN_CAPE);
    }
    if(hasClassReward(player, 'GW'))
    {
        // 'GW' reward - *G*olden *W*eapon
        // Prepend to the start of the overlay list, so that it gets drawn first (it's a full sprite replacement)
        switch(player.class)
        {
            case CLASS_SCOUT:
            case CLASS_SOLDIER:
            case CLASS_SNIPER:
            case CLASS_DEMOMAN:
            case CLASS_HEAVY:
            case CLASS_PYRO:
            case CLASS_MEDIC:
                ds_list_insert(tauntOverlays, 0, getCharacterSpriteId(player.class, player.team, "GoldWeaponTaunt"));
                break;
        }
        
        if(player.class == CLASS_HEAVY)
        {
            ds_list_insert(omnomnomnomOverlays, 0, getCharacterSpriteId(global.paramPlayer.class, global.paramPlayer.team, "OmnomnomnomGoldWeapon"));
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    loopsoundstop(UberIdleSnd);
    
    var map;
    with(currentWeapon) {
        instance_destroy();
    }
    
    with(bubble) {
        instance_destroy();
    }
    
    // Drop intel if carried. This is not done by sending an extra event because that would be a nested event, which
    // screws up order of operations (Server: do part of player death, then drop intel, then do rest of player death. Client: Do player death, drop intel for dead player, error out)
    if (intel)
    {
        doEventDropIntel(player);
        
        // lastDamageSource is not always synchronized on Character destruction (e.g. if the player just leaves), so we HAVE to sync here.
        // Let's just hope it doesn't matter whether we return the intel now (Server) or after the player destruction is finished (Client).
        if (global.isHost and (lastDamageSource == DAMAGE_SOURCE_KILL_BOX || lastDamageSource == DAMAGE_SOURCE_FRAG_BOX || lastDamageSource == DAMAGE_SOURCE_PITFALL))
        {
            var intelTeam;
            if (team == TEAM_RED)
                intelTeam = TEAM_BLUE;
            else if (team == TEAM_BLUE)
                intelTeam = TEAM_RED;
            else
                show_error("Invalid team set for Character " + player.name, true);
                
            doEventReturnIntel(intelTeam);
            sendEventReturnIntel(intelTeam);
        }
    }
    
    player.object=-1;
    if (place_meeting(x,y,SpawnRoom) or deathmatch_invulnerable != 0)
    {
        player.alarm[5] = 1;
        player.deathmatch_respawn_bypass = deathmatch_invulnerable;
    }
    else
    {
        player.alarm[5] = global.Server_Respawntime / global.delta_factor;
        player.deathmatch_respawn_bypass = 0;
    }
    
    //part type destroy
    if(variable_local_exists(id, "jumpFlameParticleType"))
        part_type_destroy(jumpFlameParticleType);
    
    if(variable_local_exists(id, "jumpDustParticleSystem"))
        part_type_destroy(jumpDustParticleSystem);
        
    // destroy overlay lists
    ds_list_destroy(stillOverlays);
    ds_list_destroy(leanROverlays);
    ds_list_destroy(leanLOverlays);
    ds_list_destroy(jumpOverlays);
    ds_list_destroy(runOverlays);
    ds_list_destroy(walkOverlays);
    ds_list_destroy(crouchOverlays);
    ds_list_destroy(tauntOverlays);
    ds_list_destroy(omnomnomnomOverlays);
    ds_list_destroy(gearList);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Reset cloak flicker after hit</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(player.class == CLASS_SPY)
{
    cloakFlicker = false;
    if(cloak)
        cloakAlpha = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sandvich cooldown</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>canEat = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Cosmetic flame randomization</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (burnDuration != 0) {
    for(i = 0; i &lt; numFlames; i += 1)
    {
        flameArray_x[i] = random_range(-(right_bound_offset - left_bound_offset)/2, (right_bound_offset - left_bound_offset)/2);
        flameArray_y[i] = random_range(-(bottom_bound_offset - top_bound_offset)/2, (bottom_bound_offset - top_bound_offset)/2);
    }
}
alarm[5] = 30 / global.delta_factor;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Kill Assist Expiration</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>secondToLastDamageDealer = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Finish Off Expiration</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>lastDamageDealer = noone;
lastDamageSource = -1;
secondToLastDamageDealer = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>End of uber</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ubered = 0;
playsound(x,y,UberEndSnd);</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>intel grabability</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>canGrabIntel=true;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Afterburn intensity stuff</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>intensityDecay = burnIntensity / decayDuration;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>charSetSolids();


// Climbing down stairs
// if we aren't falling this frame, and we're not on a dropdown platform
if(vspeed == 0 and ((keyState &amp; $02) or !place_meeting(x, y+1, DropdownPlatform) or place_meeting(x, y, DropdownPlatform)))
{ 
    if(place_free(x,y+6))
        if(!place_free(x,y+7))
            y += 6;
        else if(speed &gt; 6) if(place_free(x,y+12)) if(!place_free(x,y+13))
            y += 12;
}
xprevious = x;
yprevious = y;

charUnsetSolids();

if(global.isHost &amp;&amp; hp&lt;=0) {
    var assistant;
    assistant = secondToLastDamageDealer;
    with(lastDamageDealer)
        if (object)
            if (object.healer)
                assistant = object.healer;
                
    sendEventPlayerDeath(player, lastDamageDealer, assistant, lastDamageSource);
    doEventPlayerDeath(player, lastDamageDealer, assistant, lastDamageSource);
    with(GameServer) {
        ServerBalanceTeams();
    }
    exit;
}
    
if(hp&gt;maxHp) {
    hp=maxHp;
}
    
if(((aimDirection+270) mod 360)&gt;180) {
    image_xscale=1;
    currentWeapon.image_xscale=1;
    currentWeapon.image_angle = aimDirection;
} else {
    image_xscale=-1;
    currentWeapon.image_xscale=-1;
    currentWeapon.image_angle = aimDirection+180;
}
    
currentWeapon.x=round(x);
currentWeapon.y=round(y);
    
// Limit people to the area of the room to prevent the
// "Falling through the floors" issue.
if(x&lt;0) {
    x=0;
}
if(x&gt;map_width()){
    x = map_width();
}
if(y&lt;0) {
    y = 0;
}
if(y&gt;map_height()){
    y = map_height();
}

    
// Cloak
if (cloak and cloakAlpha &gt; 0 and !cloakFlicker)
    cloakAlpha = max(cloakAlpha - 0.05, 0);
else if (!cloak and cloakAlpha &lt; 1)
    cloakAlpha = min(cloakAlpha + 0.05, 1);
    
// Taunts
if (taunting)
{
    tauntindex += tauntspeed*0.1 * global.delta_factor;
    if (tauntindex &gt;= sprite_get_number(tauntsprite))
        taunting = false;
    if (hasClassReward(player, "TauntMoney_"))
    {
        if (tauntindex == 0.30)
            instance_create(x, y, Money);
    }
}
    
//sandvich
if (omnomnomnom)
{
    omnomnomnomindex += 0.25 * global.delta_factor;
    image_xscale=xscale;
    if(hp &lt; maxHp) // This should prevent the "ate and got hit but didn't refresh cooldown" bug
    { // Also, cooldown is now reset continually until fully healed or finished eating.
        canEat = false;
        alarm[6] = eatCooldown / global.delta_factor;
    }
    if (hp &lt;= maxHp)
        hp += 1.6 * global.delta_factor;
    if (omnomnomnomindex &gt;= omnomnomnomend)
        omnomnomnom=false;
}

//for things polling whether the character is on a medcabinet
onCabinet = place_meeting(x, y, HealingCabinet);

// Last x/y position for death cam if player is dead
player.lastKnownx=x;
player.lastKnowny=y;

// Here the view is set
if (player == global.myself)
{
    if (global.myself.class == CLASS_SNIPER and zoomed)
    {
        var relxmouse, relymouse;
        relxmouse = min(max(window_views_mouse_get_x()-view_xview[0], 0), view_wview);
        relymouse = min(max(window_views_mouse_get_y()-view_yview[0], 0), view_hview);
        
        view_xview[0] = x+relxmouse-view_wview[0];
        view_yview[0] = y+relymouse-view_hview[0];
    }
    else
    {
        view_xview[0] = x-view_wview[0]/2;
        view_yview[0] = y-view_hview[0]/2;
    }
}

realnumflames = numFlames * burnDuration / maxDuration;

// Decay deathmatch invulnerability if needed
if(deathmatch_invulnerable &gt; 0)
    deathmatch_invulnerable -= global.delta_factor * deathmatch_invuln_decay;
if(deathmatch_invulnerable &lt;= 0)
    deathmatch_invulnerable = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var stuckInWall, standingOnObstacle, onNonSurfingGround;
charSetSolids();
stuckInWall = !place_free(x,y);
obstacleBelow = !place_free(x,y+1);
charUnsetSolids();
onground = false;
onNonSurfingGround = false;
if(vspeed &gt;= 0)
{
    if(obstacleBelow)
    {
        onground = true;
        onNonSurfingGround = true;
    }
    // Check whether we're potentially standing on any platform before checking each one
    else if(!(keyState &amp; $02))
    {
        if(place_meeting(x, y+1, DropdownPlatform))
        {
            with(DropdownPlatform)
            {
                if(!place_meeting(x, y-1, other)) continue; // We can only stand on platforms immediately below us
                if(place_meeting(x, y, other)) continue;    // We can't stand on platforms we already collide with
                other.onground = true;
                if(resetMoveStatus)
                    onNonSurfingGround = true;
                // If we didn't find a nonsurfing dropdown yet, we have to keep looking
                // because there may still be one overlapping the surfing dropdown we found
                if(onNonSurfingGround) break;
            }
        }
    }
}

if(onNonSurfingGround)
    moveStatus = 0;
    
if(onground)
    doublejumpUsed = 0;

// Apply afterburn
if (global.run_virtual_ticks)
{
    if (burnDuration &gt; 0)
    {
        if(hp &gt; 0)
        {   // Don't count if someone else already finished him off, to prevent afterburn from "stealing" sticky kills (Bug #1021989)
            if (lastDamageDealer != burnedBy and lastDamageDealer != player)
            {
                secondToLastDamageDealer = lastDamageDealer;
                alarm[4] = alarm[3];
            }
            alarm[3] = ASSIST_TIME / global.delta_factor;
            lastDamageDealer = burnedBy;
            lastDamageSource = afterburnSource;
            dealDamage(lastDamageDealer, id, burnIntensity / 30);
        }
        burnDuration -= durationDecay * global.delta_factor;
        timeUnscathed = 0;
    }
    if (alarm[0] == -1 &amp;&amp; burnIntensity &gt; 0) burnIntensity -= intensityDecay;
    if (burnDuration &lt;= 0 || burnIntensity &lt;= 0)
    {
        burnDuration = 0;
        burnIntensity = 0;
        burnedBy = -1;
        afterburnSource = -1;
    }
}
// Handle input
if(player.queueJump)
{
    if (pressedKeys &amp; $80)
        wantToJump = true;
    else if (releasedKeys &amp; $80)
        wantToJump = false;
}

if(!taunting and !omnomnomnom)
{
    if(!player.humiliated and (keyState | pressedKeys) &amp; $10)
    {
        with(currentWeapon) event_user(1);
        deathmatch_invulnerable = 0;
    }
    if(!player.humiliated and pressedKeys &amp; $01)  {
        if (!invisible &amp;&amp; cloakAlpha == 1)
            taunting=true;
        tauntindex=0;
        image_speed=tauntspeed;
    } 
    
    if(((pressedKeys &amp; $80) or (player.queueJump and wantToJump)) and vspeed &gt; -jumpStrength)
    {
        if (onground and !stuckInWall)
        {
            deathmatch_invuln_decay = 1;
            if(not stabbing)
            {
                wantToJump = false;
                playsound(x,y,JumpSnd);
                vspeed = -jumpStrength;
                onground = false; // Correct unless you are standing on a platform which moves up faster than jumpStrength
            }
        }
        else if(canDoublejump and !doublejumpUsed)
        {
            deathmatch_invuln_decay = 1;
            wantToJump = false;
            vspeed = -jumpStrength;
            onground = false; // Correct unless you are standing on a platform which moves up faster than jumpStrength
            playsound(x,y,JumpSnd);
            doublejumpUsed = 1;
            moveStatus = 0;
        }
    }
}

// Right click
if (!player.humiliated and ((keyState | pressedKeys) &amp; $08)
    and (!taunting or player.class == CLASS_DEMOMAN) and !omnomnomnom)
{
    deathmatch_invulnerable = 0;
    with(currentWeapon)
        event_user(2);
}

// Cloak
if (!player.humiliated &amp;&amp; (pressedKeys &amp; $08)
    &amp;&amp; canCloak &amp;&amp; ((cloakAlpha == 1 and !cloak) or cloak)
    &amp;&amp; !intel  &amp;&amp; !taunting)
{
    deathmatch_invulnerable = 0;
    if(currentWeapon.readyToStab) {
        if (cloak) { // stop spies immediately picking up intel after uncloaking
            canGrabIntel = false;
            alarm[1] = max(alarm[1], 25 / global.delta_factor); // avoid decreasing the alarm on accident
        }
        cloak = !cloak;
    }
}

switch(moveStatus) // moveStatus is reset in collision with ceilings (including doors if they reject you)
{
case 1: //If I am rocketing/mining myself
    controlFactor = 0.65;
    frictionFactor = 1;
    break;
case 2: //If I am rocketing/mining an enemy
    controlFactor = 0.45;
    frictionFactor = 1.05;
    break;
case 3: //Airblast
    controlFactor = 0.35;
    frictionFactor = 1.05;
    break;
case 4: //If I am rocketing/mining a teamate
    controlFactor = baseControl;
    frictionFactor = 1;
    break;
default:
    if (player.humiliated)
        controlFactor = baseControl-0.2;
    else if (intel)
        controlFactor = baseControl-0.1;
    else
        controlFactor = baseControl;
    frictionFactor = baseFriction;
}

var rocketJumping;
rocketJumping = moveStatus == 1 or moveStatus == 2 or moveStatus == 4;
if(rocketJumping)
{
    if(global.run_virtual_ticks)
    {
        if (!variable_local_exists(id, "jumpFlameParticleType"))
        {
            jumpFlameParticleType = part_type_create();
            part_type_sprite(jumpFlameParticleType,FlameS,true,false,true);
            part_type_alpha2(jumpFlameParticleType,1,0.3);
            part_type_life(jumpFlameParticleType,2,5);
            part_type_scale(jumpFlameParticleType,0.7,-0.65);
        }
        
        if !variable_global_exists("jumpFlameParticleSystem")
        {
            global.jumpFlameParticleSystem = part_system_create();
            part_system_depth(global.jumpFlameParticleSystem, 10);
        }
        
        if(global.particles == PARTICLES_NORMAL)
        {
            if(random(1) &gt; (controlFactor+frictionFactor)/2)
            {
                effect_create_below(ef_smoke,x-hspeed*1.2,y-vspeed*1.2+20,0,c_gray);
            }
        }
        if(global.particles == PARTICLES_NORMAL or global.particles == PARTICLES_ALTERNATIVE)
        {
            if(random(7) &lt; 5)
            {
                part_particles_create(global.jumpFlameParticleSystem,x,y+19,jumpFlameParticleType,1);
            }
        }
    }
}

if(spinjumping)
{
    
    if (!variable_local_exists(id, "jumpDustParticleType"))
    {
        jumpDustParticleType = part_type_create();
        part_type_sprite(jumpDustParticleType,SpeedBoostS,false,false,true);
        part_type_alpha3(jumpDustParticleType,0.7,0.5,0);
        part_type_life(jumpDustParticleType,15,30);
        part_type_scale(jumpDustParticleType,1,1);
        part_type_orientation(jumpDustParticleType, -90, -90, 0, 0, 0);
    }
    if !variable_global_exists("jumpDustParticleSystem")
    {
        global.jumpDustParticleSystem = part_system_create();
        part_system_depth(global.jumpDustParticleSystem, 10);
    }
    
    if(global.particles == PARTICLES_NORMAL or global.particles == PARTICLES_ALTERNATIVE)
    {
        if(random(4) &lt; 4)
        {
            if(sign(_last_xscale) &lt; 0)
                part_particles_create(global.jumpDustParticleSystem,x+right_bound_offset+1,y+bottom_bound_offset-4,jumpDustParticleType,1);
            else
                part_particles_create(global.jumpDustParticleSystem,x+left_bound_offset +2,y+bottom_bound_offset-4,jumpDustParticleType,1);
        }
    }
}

controlling = false;
repeat(global.frameskip)
{
    // Do movement
    if(!taunting &amp;&amp; !omnomnomnom)
    {
        if((keyState|pressedKeys) &amp; $40 and hspeed &gt;= -basemaxspeed)
        {
            hspeed -= runPower*controlFactor * global.skip_delta_factor;
            controlling = true;
        }
        if((keyState|pressedKeys) &amp; $20 and hspeed &lt;= basemaxspeed)
        {
            hspeed += runPower*controlFactor * global.skip_delta_factor;
            controlling = !controlling; // cancel out 'controlling' if both buttons are pressed
        }
    }
    // divide friction as normal if going way too fast
    if(abs(hspeed) &gt; basemaxspeed * 2 or
       ((keyState|pressedKeys) &amp; $60 and abs(hspeed) &lt; basemaxspeed))
        hspeed /= delta_mult_skip(baseFriction);
    else //otherwise divide by the moveStatus's friction
        hspeed /= delta_mult_skip(frictionFactor);
}
if(controlling)
    deathmatch_invuln_decay = 1;
    
pressedKeys = 0;
releasedKeys = 0;

// flame bubble
if burnDuration&gt;0 &amp;&amp; player.class != CLASS_PYRO and random(80) &lt;= 1 {
    setChatBubble(player, 49);
}

// stop players who are moving too slowly (avoid "ice skating")
if (abs(hspeed) &lt; 0.195 and !controlling)
{
    hspeed=0;
}

// In order to make the gravity truly framerate-independent, we need to apply half of it before, and half of it after, each motion.
// The math concept is, the period of a frame starts with a vertical velocity of N, and ends with N+gravity. This ends up being equivalent to the above idea.
// Old gg2 gravity "skipped" arcs, and behaved very slightly differently on 60fps and 30fps.
// Using truly framerate-indepent gravity means that the strength of jumping has to change to create the same arc.
// The change in the strength of jumping corresponds to the change in the strength of the initial frame of gravity.
// Since the inital frame of gravity is half what it used to be, the strength of jumping needs to change the same amount, which I did elsewhere.
// I used the 30fps value of "initial frame of gravity", since that represents gg2's canonical jump arc.
// This change PROBABLY makes explosive jumping slightly more powerful, because the initial strength of that cannot be tweaked without also altering mid-air arcs.
// Actually, because GG2 used to not apply on the first frame after jumping, jumping velocity is slightly larger, not smaller.
if(!onground and !stuckInWall)
{
    if(rocketJumping)
        applied_gravity += 0.54;
    else
        applied_gravity += 0.6;        
}

if (intel)
{
    deathmatch_invulnerable = 0; // in case anyone ever applies this code to another gamemode
    if (global.run_virtual_ticks)
    {
        if (speed &gt; 0.195)
        {
            if (random(1) &gt; 0.90)
            {
                var sheet;
                sheet = instance_create(x,y-11+random(9),LooseSheet);
                sheet.hspeed = hspeed;
                if (hasReward(player, "GoldTrail"))
                    sheet.sprite_index = choose(SheetFallingGold1, SheetFallingGold2, SheetFallingGold3);
            }
        }
        else if (random(1) &gt; 0.975)
        {
            var sheet;
            sheet = instance_create(x,y-11+random(9),LooseSheet);
            sheet.hspeed = hspeed;
            if (hasReward(player, "GoldTrail"))
                sheet.sprite_index = choose(SheetFallingGold1, SheetFallingGold2, SheetFallingGold3);
        }
    }
    if (cloak)
    {
        cloak=false;
        cloakAlpha=1;
    }
    if (!omnomnomnom) // Do not recharge intel timer if eating
        intelRecharge = min(INTEL_MAX_TIMER, // Cap timer charge at the intel timer's length (bandwidth)
                            intelRecharge + global.delta_factor * // ...After adding some value to it 
                            INTEL_MAX_TIMER/((3+abs(min(hspeed, 7))/3.5)*30)); // ...Which starts at a rate of full charge per three seconds, and reduces linearly with speed, down to full charge per five seconds with a scout's max speed
}

if(player.humiliated)
    deathmatch_invulnerable = 0;

var sprite_length;
if(player.class == CLASS_QUOTE or sprite_special or zoomed or player.humiliated)
    sprite_length = 2;
else
    sprite_length = CHARACTER_ANIMATION_LEN;

var jumpAnimationImage;
if(player.humiliated)
    jumpAnimationImage = 2;
else
    jumpAnimationImage = 1;

if (onground and hspeed == 0)
    animationImage = 0;
else if(!onground)
    animationImage = jumpAnimationImage;
else
{
    // onground and not still
    animationImage += min(abs(hspeed), 8)*sign(hspeed)*image_xscale*global.delta_factor/20;
    animationImage = (animationImage+sprite_length) mod sprite_length;
}

// drop intel if ubered or round is over
if (intel and (ubered or global.mapchanging) and global.isHost) {
    sendEventDropIntel(player);
    doEventDropIntel(player);
}

//gotta regenerate some nuts
nutsNBolts = min(nutsNBolts+(0.1 * global.delta_factor), maxNutsNBolts);

//ubered max out ammo and extinguish flames
if ubered {
    if (burnIntensity &gt; 0 || burnDuration &gt; 0)
    {
        burnIntensity = 0;
        burnDuration = 0;
        burnedBy = -1;
    }
    if instance_exists(currentWeapon) {
        with(currentWeapon) {
            if(variable_local_exists(id, "maxAmmo")) {
                ammoCount = maxAmmo;
            }
            if (alarm[5] &gt; 0)
            {
                // Stop the animation
                event_perform(ev_alarm, 5);
            }
            alarm[5] = -1;
        }
    }
}

//give max ammo for players on the winning team
var arenaRoundEnd;
arenaRoundEnd = false;
if (instance_exists(ArenaHUD)) { 
    arenaRoundEnd = (ArenaHUD.state == ArenaHUD.ARENA_STATE_ROUND_END);
}

if ((arenaRoundEnd or global.mapchanging) and !player.humiliated) {
    if instance_exists(currentWeapon) {
        with(currentWeapon){
            if(variable_local_exists(id, "maxAmmo")) {
                ammoCount = maxAmmo;
            }
            if (alarm[5] &gt; 0)
            {
                // Stop the animation
                event_perform(ev_alarm, 5);
            }
            alarm[5] = -1;
        }
    }
}

//drop cloak and unscope if on losing team or stalemate
if (player.humiliated)
{
    if (zoomed)
        toggleZoom(id);
    if (!stabbing)
        cloak = false;
}

// Determine if the character is capturing a CP, and which
var zone;
zone = collision_point(x,y,CaptureZone,0,0);

if(zone &gt;= 0 and !cloak and cloakAlpha == 1)
{
    cappingPoint = zone.cp;
    deathmatch_invulnerable = 0; // in case anyone ever applies this code to another gamemode
}
else
    cappingPoint = noone;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>charSetSolids();

// Limit speed to prevent obstacle penetration
// (each dimension separately to avoid one vector affecting the other)
hspeed = min(abs(hspeed), 15) * sign(hspeed);
vspeed = min(abs(vspeed), 15) * sign(vspeed);

// Pretty sure this is for the healing ramp (crit heals)
// Done here instead of begin step to avoid code execution order mistakes
timeUnscathed = min(timeUnscathed+1*global.delta_factor, 10*30);

// Spinjumping emulation
if(global.run_virtual_ticks)
{
    if (sign(hspeed) &gt; 0) // See if we're "spinning", also mirror which side gets the boost so that the effect of spinjumping is perfectly symmetric
        _test = _last_xscale &gt; image_xscale;
    else
        _test = _last_xscale &lt; image_xscale;


    if (_test and !place_free(x+sign(hspeed), y)) // Rubbing wall and spinning
        spinjumping = true;
    else
        spinjumping = false;


    _last_xscale = image_xscale;
}

if(moveStatus == 1 or moveStatus == 2 or moveStatus == 4) // Make an anti-gravity for what our physics gravity should be (at 30fps)
    _gravity = 0.54;
else
    _gravity = 0.6;

if (spinjumping and
    place_free(x, y-_gravity) // validity check
    and (place_free(x, y+1) or vspeed &lt; 0) // In air, or jumping
   )
    applied_gravity -= _gravity;
else
    spinjumping = false; // prevent phantom spinjump dust

// The change in vspeed for gravity for DURATION of this frame (not the end of it!) is half the change there is by the end of it (see?)
// See gravity comments in Begin Step for rationale.
vspeed += applied_gravity*global.delta_factor/2;
if(vspeed &gt; 10)
    vspeed = 10;

// Run movement solver if necessary
yprevious = y;
xprevious = x;
y_previous = y;
x_previous = x;

var doHit;
doHit = !place_free(x+hspeed*global.delta_factor, y+vspeed*global.delta_factor);

if(doHit)
{
    characterHitObstacle();
}
else
{
    x += hspeed * global.delta_factor;
    y += vspeed * global.delta_factor;
}

// Fallback
if(place_free(x, y+1))
    vspeed += applied_gravity*global.delta_factor/2;
if(vspeed &gt; 10)
    vspeed = 10;
applied_gravity = 0;

// Handle dropdown platforms
if(!(keyState &amp; $02))
{
    with(DropdownPlatform)
    {
        if(other.y &lt; other.y_previous) continue;
        if(!place_meeting(x, y, other)) continue;
        if(place_meeting(x, y + (other.y - other.y_previous), other)) continue;
    
        with(other)
        {
            while(place_meeting(x, y, other) and place_free(x, y - 0.1))
                y -= 0.1;
            vspeed = 0;
        }
    }
}

x -= hspeed;
y -= vspeed;

charUnsetSolids();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="RightDoor">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//only allow passage from the right hand side, otherwise get blocked
if(hspeed &gt; 0)
{   
    if (x+right_bound_offset - hspeed &lt;= other.bbox_left + 2)
    {
        x = other.x - right_bound_offset;
        hspeed = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="LeftDoor">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//only allow passage from the left hand side, otherwise get blocked
if(hspeed &lt; 0)
{
    var door_bbox_right;
    door_bbox_right = other.bbox_right;
    if(x+left_bound_offset-hspeed &gt;= door_bbox_right-2)
    {
        x = door_bbox_right - left_bound_offset;
        hspeed = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="FragBox">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>playsound(x,y,ExplosionSnd);
hp=0;
if (instance_exists(lastDamageDealer) &amp;&amp; lastDamageDealer != player)
    lastDamageSource = DAMAGE_SOURCE_FINISHED_OFF_GIB;
else
    lastDamageSource = DAMAGE_SOURCE_FRAG_BOX;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="PitFall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hp=0;
if (instance_exists(lastDamageDealer) &amp;&amp; lastDamageDealer != player)
    lastDamageSource = DAMAGE_SOURCE_FINISHED_OFF;
else
    lastDamageSource = DAMAGE_SOURCE_PITFALL;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="KillBox">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hp=0;
if (instance_exists(lastDamageDealer) &amp;&amp; lastDamageDealer != player)
    lastDamageSource = DAMAGE_SOURCE_FINISHED_OFF;
else
    lastDamageSource = DAMAGE_SOURCE_KILL_BOX;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="MoveBoxDown">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>moveStatus = 0;
if (global.run_virtual_ticks) vspeed += other.pushPower;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="MoveBoxUp">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>moveStatus = 0;
if (global.run_virtual_ticks) vspeed -= other.pushPower;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="MoveBoxLeft">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>moveStatus = 0;
if (global.run_virtual_ticks) hspeed -= other.pushPower;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="MoveBoxRight">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>moveStatus = 0;
if (global.run_virtual_ticks) hspeed += other.pushPower;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="HealingCabinet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.mapchanging) {
    if ((hp &lt; maxHp or nutsNBolts &lt; 100 or !canEat) and other.heal)
    {
        if(instance_exists(TeamDeathmatchHUD))
            hp += global.delta_factor/30*10; // 10 hp per second
        else
        {
            playsound(x,y,CbntHealSnd);
            hp = maxHp;
            nutsNBolts = maxNutsNBolts;
            alarm[6] = 0;
            canEat = true; // FIXME: redundant with resetting alarm 6?
        }
    }
    if (burnIntensity &gt; 0 or burnDuration &gt; 0)
    {
        burnIntensity = 0;
        burnDuration = 0;
        burnedBy = -1;
        afterburnSource = -1;
    }
    //ammo stuffs
    if (other.refill) {
        if(currentWeapon.ammoCount &lt; currentWeapon.maxAmmo) {
            switch(currentWeapon.object_index) {
            case Medigun:
            case Minigun:
            case Flamethrower:
            case Blade:
                if (currentWeapon.ammoCount / currentWeapon.maxAmmo &lt; 5/6)
                    playsound(x,y,PickupSnd);
                break;
            default:
                playsound(x,y,PickupSnd);
                break;
            }
            currentWeapon.ammoCount = currentWeapon.maxAmmo;
            switch(currentWeapon.object_index) {
            case Rocketlauncher:
            case Scattergun:
            case Shotgun:
            case Revolver:
            case Medigun:
                with(currentWeapon)
                {
                    if (alarm[5] &gt; 0)
                    {
                        // Stop the animation
                        event_perform(ev_alarm, 5);
                    }
                    alarm[5] = -1;
                }
                break;
            }
        }
    }
    if (other.uber and currentWeapon.object_index == Medigun) {
        if (global.isHost and !currentWeapon.uberReady and !currentWeapon.ubering) {
            sendEventUberReady(player);
            doEventUberReady(player);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="Desensitizer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="IntelligenceBlue">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Intelligence grabbing is synced now, so it's only tested on the server
if(global.isHost and !global.mapchanging)
{
    if(team == TEAM_RED and !place_meeting(x,y,TeamGate) and (canGrabIntel or other.alarm[0] &lt;= 1) and !ubered and !cloak)
    {
        sendEventGrabIntel(player);
        doEventGrabIntel(player);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="IntelligenceRed">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Intelligence grabbing is synced now, so it's only tested on the server
if(global.isHost and !global.mapchanging and !instance_exists(InvasionHUD))
{
    if(team == TEAM_BLUE and !place_meeting(x,y,TeamGate) and (canGrabIntel or other.alarm[0] &lt;= 1) and !ubered and !cloak)
    {
        sendEventGrabIntel(player);
        doEventGrabIntel(player);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="IntelligenceBaseRed">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.isHost) {
    if(team == TEAM_RED and intel == true) {
        sendEventScoreIntel(player);
        doEventScoreIntel(player);
        GameServer.syncTimer = 1;
    }
}</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="IntelligenceBaseBlue">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(global.isHost) {
    if(team == TEAM_BLUE and intel == true) {
        sendEventScoreIntel(player);
        doEventScoreIntel(player);
        GameServer.syncTimer = 1;
    }
}</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="SentryGibs">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if player.class == CLASS_ENGINEER &amp;&amp; nutsNBolts &lt; maxNutsNBolts {
    with other instance_destroy();
    nutsNBolts += 50;
    playsound(x,y,PickupSnd);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    receiveCompleteMessage(global.serverSocket,4,global.deserializeBuffer);
    keyState = fct_read_ubyte(global.deserializeBuffer);
    aimDirection = fct_read_ushort(global.deserializeBuffer)*360/65536;
    aimDistance = fct_read_ubyte(global.deserializeBuffer)*2;
    
    var temp, newIntel;
    if(global.updateType == QUICK_UPDATE) or (global.updateType == FULL_UPDATE) {
        receiveCompleteMessage(global.serverSocket,9,global.deserializeBuffer);
        x = fct_read_ushort(global.deserializeBuffer)/5;
        y = fct_read_ushort(global.deserializeBuffer)/5;
        hspeed = fct_read_byte(global.deserializeBuffer)/8.5;
        vspeed = fct_read_byte(global.deserializeBuffer)/8.5;
        xprevious = x;
        yprevious = y;
        
        hp = fct_read_ubyte(global.deserializeBuffer);
        currentWeapon.ammoCount = fct_read_ubyte(global.deserializeBuffer);
        
        temp = fct_read_ubyte(global.deserializeBuffer);
        cloak = (temp &amp; $01 != 0);
        moveStatus = (temp &gt;&gt; 1) &amp; $07;
    }
    
if(global.updateType == FULL_UPDATE){
        receiveCompleteMessage(global.serverSocket,7,global.deserializeBuffer);
        animationOffset = fct_read_ubyte(global.deserializeBuffer);
        //class specific syncs
        switch(player.class)
        {
        case CLASS_SPY:
            cloakAlpha = fct_read_ubyte(global.deserializeBuffer)/255;
            break;
        case CLASS_MEDIC:
            currentWeapon.uberCharge = fct_read_ubyte(global.deserializeBuffer)*2000/255;
            break;
        case CLASS_ENGINEER:
            nutsNBolts = fct_read_ubyte(global.deserializeBuffer);
            break;
        case CLASS_SNIPER:
            currentWeapon.t = fct_read_ubyte(global.deserializeBuffer);
            if(currentWeapon.t) zoomed = true; // Quick hack
            break;
        default:
            fct_read_ubyte(global.deserializeBuffer)
        }
        alarm[1] = fct_read_short(global.deserializeBuffer)/global.delta_factor; 
        if (alarm[1] != 0)
            canGrabIntel = false;
        intel = fct_read_ubyte(global.deserializeBuffer);
        intelRecharge = fct_read_short(global.deserializeBuffer);
        with(currentWeapon) {
            event_user(13);
        }
    }
    event_user(1);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    var temp;
    fct_write_ubyte(global.serializeBuffer, keyState);
    fct_write_ushort(global.serializeBuffer, netAimDirection);
    fct_write_ubyte(global.serializeBuffer, aimDistance/2);

    if(global.updateType == QUICK_UPDATE or global.updateType == FULL_UPDATE) {
        fct_write_ushort(global.serializeBuffer, x*5);
        fct_write_ushort(global.serializeBuffer, y*5);
        fct_write_byte(global.serializeBuffer, hspeed*8.5);
        fct_write_byte(global.serializeBuffer, vspeed*8.5);
        fct_write_ubyte(global.serializeBuffer, ceil(hp));
        fct_write_ubyte(global.serializeBuffer, currentWeapon.ammoCount);
        
        temp = 0;
        if(cloak) temp |= $01;
        //allocate the next three bits of the byte for movestatus sync
        temp |= (moveStatus &amp; $07) &lt;&lt; 1;
        fct_write_ubyte(global.serializeBuffer, temp);               
    }
   

if(global.updateType == FULL_UPDATE){
    fct_write_ubyte(global.serializeBuffer, animationOffset);
    
    //class specific syncs
    switch(player.class)
    {
    case CLASS_SPY:
        fct_write_ubyte(global.serializeBuffer, cloakAlpha*255);
        break;
    case CLASS_MEDIC:
        fct_write_ubyte(global.serializeBuffer, currentWeapon.uberCharge*255/2000);
        break;
    case CLASS_ENGINEER:
        fct_write_ubyte(global.serializeBuffer, nutsNBolts);
        break;
    case CLASS_SNIPER:
        fct_write_ubyte(global.serializeBuffer, currentWeapon.t);
        break;
    default:
        fct_write_ubyte(global.serializeBuffer, 0);
    }
    fct_write_short(global.serializeBuffer, alarm[1]*global.delta_factor);
    fct_write_ubyte(global.serializeBuffer, intel);
    fct_write_short(global.serializeBuffer, intelRecharge);
    
    with(currentWeapon) {
        event_user(12);
    }
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Make a "ghost" copy of our sprite.
// For Infiltrators only.
var ghost;
ghost = instance_create(x, y, SpyGhost);
// We don't have a Ghost image for every animation image of the Spy, so we just
// use the first one now.
ghost.image_index = 0;
ghost.image_xscale = image_xscale;
ghost.associatedCharacter = id;
if(stabbing)
    ghost.cloakAlpha = 1;
else
    ghost.cloakAlpha = cloakAlpha;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>{
    pressedKeys |= keyState &amp; ~lastKeyState;
    releasedKeys |= ~keyState &amp; lastKeyState;
    lastKeyState = keyState;
}</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>xoffset = view_xview[0];
yoffset = view_yview[0];
xsize = view_wview[0];
ysize = view_hview[0];

if (distance_to_point(xoffset+xsize/2,yoffset+ysize/2) &gt; 800)
    exit;

if(intel and intelRecharge &lt; 900)
    draw_intel_timer(intelRecharge/900, team == TEAM_RED, -8);

draw_set_alpha(0.3);
// backing halo for deathmatch-invulnerable players
if(deathmatch_invulnerable != 0) // must be != 0
{
    draw_circle_color(x, y, 50, c_white, c_white, false);
    if((deathmatch_invulnerable &gt; 0) and global.tdmInvulnerabilityTicks != 0)
        draw_circle_color(x, y, deathmatch_invulnerable/global.tdmInvulnerabilityTicks*50.5, c_white, c_white, false);
    else
        draw_circle_color(x, y, 50.5, c_white, c_white, false);
}
draw_set_alpha(1);

var xr, yr;
xr = round(x);
yr = round(y);

image_alpha = cloakAlpha;

if (global.myself.team == team and canCloak)
    image_alpha = cloakAlpha/2 + 0.5;

if (invisible)
    exit;

if(stabbing)
    image_alpha -= power(currentWeapon.stab.alpha, 2);

if (team == global.myself.team and (player != global.myself or global.showHealthBar))
{
    draw_set_alpha(1);
    draw_healthbar(xr-10, yr-30, xr+10, yr-25,hp*100/maxHp,c_black,c_red,c_green,0,true,true);
}

draw_set_alpha(1);
if (team == TEAM_RED)
    ubercolour = c_red;
else
    ubercolour = c_blue;

// sprite resource selection
var sprite, overlayList, noNewAnim, sprite_tilt_left, sprite_tilt_right, overlays_tilt_left, overlays_tilt_right;
noNewAnim = player.class == CLASS_QUOTE or sprite_special or player.humiliated;

if (zoomed)
{
    if (team == TEAM_RED)
        sprite = SniperRedCrouchS;
    else
        sprite = SniperBlueCrouchS;
    overlayList = crouchOverlays;
    animationImage = animationImage mod 2; // sniper crouch only has two frames, avoid overflow
}
// most classes, check for running jumping and standing
else if (!noNewAnim)
{
    if(!onground)
    {
        sprite = spriteJump;
        overlayList = jumpOverlays;
    }
    else
    {
        if(hspeed==0)
        {
            // set up vars for slope detection
            charSetSolids();
            if(image_xscale &gt; 0)
            {
                sprite_tilt_left = spriteLeanL;
                sprite_tilt_right = spriteLeanR;
                overlays_tilt_left = leanLOverlays;
                overlays_tilt_right = leanROverlays;
            }
            else
            {
                sprite_tilt_left = spriteLeanR;
                sprite_tilt_right = spriteLeanL;
                overlays_tilt_left = leanROverlays;
                overlays_tilt_right = leanLOverlays;
            }
            
            // default still sprite
            sprite = spriteStand;
            overlayList = stillOverlays;
            
            { // detect slopes
                var openright, openleft;
                openright = !collision_point_solid(x+6, y+bottom_bound_offset+2) and !collision_point_solid(x+2, y+bottom_bound_offset+2);
                openleft = !collision_point_solid(x-7, y+bottom_bound_offset+2) and !collision_point_solid(x-3, y+bottom_bound_offset+2);
                if (openright)
                {
                    sprite = sprite_tilt_right;
                    overlayList = overlays_tilt_right;
                }
                if (openleft)
                {
                    sprite = sprite_tilt_left;
                    overlayList = overlays_tilt_left;
                }
                if (openright and openleft)
                {
                    openright = !collision_point_solid(x+right_bound_offset, y+bottom_bound_offset+2);
                    openleft = !collision_point_solid(x-left_bound_offset, y+bottom_bound_offset+2);
                    if (openright)
                    {
                        sprite = sprite_tilt_right;
                        overlayList = overlays_tilt_right;
                    }
                    if (openleft)
                    {
                        sprite = sprite_tilt_left;
                        overlayList = overlays_tilt_left;
                    }
                }
            }
                
            charUnsetSolids();
        }
        else
        {
            sprite = spriteRun;
            overlayList = runOverlays;
            if (player.class == CLASS_HEAVY and abs(hspeed) &lt; 3) // alternative sprite for extremely slow moving heavies
            {
                if (team == TEAM_RED)
                {
                    sprite = HeavyRedWalkS;
                    overlayList = walkOverlays;
                }
                else
                {
                    sprite = HeavyBlueWalkS;
                    overlayList = walkOverlays;
                }
            }
        }
    }
}
else
{
    sprite = sprite_index;
    overlayList = stillOverlays;
}

if (sprite != sprite_index and (sprite == spriteLeanR or sprite == spriteLeanL)
    and !taunting and !omnomnomnom and !stabbing // These override "sprite"
    and !noNewAnim)
    yoffset = 6;
else
    yoffset = 0;

equipmentOffset = ((sprite == spriteRun) and
                (floor(animationImage) mod 2) == 0)
               and onground;
equipmentOffset *= -2; // two pixels up for whether the sprite is bobbing(above expression gives one down)

overlayOffset = equipmentOffset;

if ((player.class == CLASS_HEAVY and abs(hspeed) &lt; 3) or player.class == CLASS_SOLDIER or noNewAnim or taunting)
{
    equipmentOffset = 0; // override run bob for classes with no run bob
    overlayOffset = 0;
}
else if (abs(hspeed) &lt; 3 and equipmentOffset = -2 and !taunting)
{
    equipmentOffset += 2;
    yr += 2;
    overlayOffset = equipmentOffset-2; // mad because overlays use yr
}
else
    overlayOffset = equipmentOffset;

if(!noNewAnim) // quote and sniper zoom still use the old anim system so animationOffset is still set, override it here for everything else
    animationOffset = 0;


equipmentOffset += yoffset;

yr += yoffset;

if (omnomnomnom)
{
    draw_sprite_ext_overlay(omnomnomnomSprite,omnomnomnomOverlays,gearList,omnomnomnomindex,xr,yr,image_xscale,image_yscale,image_angle,c_white,1);
    if (ubered)
        draw_sprite_ext_overlay(omnomnomnomSprite,omnomnomnomOverlays,gearList,omnomnomnomindex,xr,yr,image_xscale,image_yscale,image_angle,ubercolour,0.7);
}
else if (taunting)
{
    draw_sprite_ext_overlay(tauntsprite,tauntOverlays,gearList,tauntindex,xr,yr,image_xscale,image_yscale,image_angle,c_white,1);
    if (ubered)
        draw_sprite_ext_overlay(tauntsprite,tauntOverlays,gearList,tauntindex,xr,yr,image_xscale,image_yscale,image_angle,ubercolour,0.7);
}
else if (player.humiliated)
    draw_sprite_ext(humiliationPoses,floor(animationImage)+humiliationOffset,xr,yr,image_xscale,image_yscale,image_angle,c_white,image_alpha);
else if (!taunting)
{
    if (intel and player.class != CLASS_QUOTE and !zoomed)
        draw_sprite_ext(spriteIntel,0,xr,round(y)+equipmentOffset, image_xscale, image_yscale, 0, c_white, image_alpha);
    if (zoomed)
        overlayOffset += 4;
    if (cloak)
    {
        if (!ubered)
            draw_sprite_ext_overlay(sprite,-1,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,c_white,image_alpha);
        else if (ubered)
        {
            draw_sprite_ext_overlay(sprite,-1,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,c_white,1);
            draw_sprite_ext_overlay(sprite,-1,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,ubercolour,0.7);
        }
    }
    else
    {
        if (!ubered)
            draw_sprite_ext_overlay(sprite,overlayList,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,c_white,image_alpha,overlayOffset);
        else if (ubered)
        {
            draw_sprite_ext_overlay(sprite,overlayList,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,c_white,1,overlayOffset);
            draw_sprite_ext_overlay(sprite,overlayList,gearList,animationImage+animationOffset,xr,yr,image_xscale,image_yscale,image_angle,ubercolour,0.7,overlayOffset);
        }
    }
}

if (burnDuration &gt; 0 or burnIntensity &gt; 0)
{
    for(i = 0; i &lt; realnumflames; i += 1)
    {
        draw_sprite_ext(FlameS, (alarm[5] * global.delta_factor) + i + random(2), x + flameArray_x[i], y + flameArray_y[i], 1, 1, 0, c_white, burnIntensity / maxIntensity * 0.5 + 0.25);
    }  
}

//Domination Indicator
if (domination_kills_get(player.dominationKills, global.myself) &gt; 3)
    draw_sprite_ext(DominationS, player.team, xr, yr-35, 1, 1, 0, c_white, cloakAlpha);

if (distance_to_point(mouse_x, mouse_y) &lt; 25)
{
    if (cloak and team != global.myself.team)
        exit;
    draw_set_alpha(1);
    if(team == TEAM_RED)
        draw_set_color(c_red);
    else
        draw_set_color(c_blue);
    
    var width, height;
    width = name_width_badges(player);
    height = string_height(sanitiseNewlines(player.name));
    
    draw_name_badges(round(xr - width / 2), round(y) - 35 - height, player, 1);
    draw_set_halign(fa_center);
    draw_set_valign(fa_bottom);
    
    if(team == global.myself.team &amp;&amp; global.showTeammateStats)
    {
        if(weapons[0] == Medigun)
            draw_text(xr,round(y)+50, "Superburst: " + string(currentWeapon.uberCharge/20) + "%");
        else if(weapons[0] == Shotgun)
            draw_text(xr,round(y)+50, "Nuts 'N' Bolts: " + string(nutsNBolts));
        else if(weapons[0] == Minegun)
            draw_text(xr,round(y)+50, "Lobbed Mines: " + string(currentWeapon.lobbed));
    }
}

// Copied from Lorgan's itemserver "angels" with slight modifications
// All credit be upon him
if (demon != -1)
{
    demonX = median(x-40,demonX,x+40);
    demonY = median(y-40,demonY,y);
    demonOffset += demonDir;
    if (abs(demonOffset) &gt; 15)
        demonDir *= -1;

    var dir;
    if (demonX &gt; x)
        dir = -1;
    else
        dir = 1;

    if (demonFrame &gt; sprite_get_number(demon))
        demonFrame = 0;

    if (stabbing || ubered)
        draw_sprite_ext(demon,demonFrame+floor(animationImage)+7*player.team,demonX,demonY+demonOffset,dir*1,1,0,c_white,1);
    else
        draw_sprite_ext(demon,demonFrame+floor(animationImage)+7*player.team,demonX,demonY+demonOffset,dir*1,1,0,c_white,image_alpha);

    demonFrame += 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
