<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>ControlPointNeutralS</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_user(0);</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alpha += fade;
if(alpha &gt;= 1) {
    fade = -0.05 * global.delta_factor;
} else if(alpha &lt;= 0) {
    fade = 0.05 * global.delta_factor;
}

var arenaRoundEnd;
arenaRoundEnd = false;
if(mode == 2) {
    if(ArenaHUD.state == ArenaHUD.ARENA_STATE_ROUND_END) arenaRoundEnd=true;
} else if (mode == 4) {  
    if (DKothHUD.cpUnlock&gt;0) 
        locked = true; 
    else //bruteforce because the below code won't lock the two edge cases without causing errors in other modes.
    {
        if (cp == 1) { if (global.cp[2].team == TEAM_RED) locked = true else locked = false; }
        if (cp == 2) { if (global.cp[1].team == TEAM_BLUE) locked = true else locked = false; }
    }
} else if (mode != 3){
    // Locking is done externally in Arena mode and KotH
    if(team == TEAM_BLUE) {
        if(cp &gt; 1) {
            if(global.cp[cp-1].team != TEAM_RED) locked = true;
            else locked = false;
        }
    } else if(team == TEAM_RED) {
        if(cp &lt; global.totalControlPoints) {
            if(global.cp[cp+1].team != TEAM_BLUE) locked = true;
            else locked = false;
        }
    }
    
    if(mode==1 &amp;&amp; team == TEAM_RED) locked = true;
}

//autolock if the round is over, regardless of game mode
if (arenaRoundEnd || global.mapchanging) locked = true;

if(locked)
{
    capping = 0;
    exit;
}

var randomRedCapper, randomBlueCapper, redCappers, blueCappers, myselfOnPoint, soundx, soundy;
var oldRedPresence, oldBluePresence;

oldRedPresence = redPresence;
oldBluePresence = bluePresence;
redPresence = 0;
bluePresence = 0;
redCappers = 0;
blueCappers = 0;
myselfOnPoint = false;
cappers = 0;

if(not arenaRoundEnd) {
    // At the end of an arena round players on the CP are no longer counted 
    with(Character) {
        if(cappingPoint==other.id) {
            if(player == global.myself) {
                myselfOnPoint = true;
            }
            
            if(player.team == TEAM_RED) {
                if(ubered) {
                    other.redPresence = max(1, other.redPresence);
                } else {
                    other.redPresence = max(2, other.redPresence);
                    redCappers += capStrength;
                }
                randomRedCapper = id;
            } else {
                if(ubered) {
                    other.bluePresence = max(1, other.bluePresence);
                } else {
                    other.bluePresence = max(2, other.bluePresence);
                    blueCappers += capStrength;
                }
                randomBlueCapper = id;
            }
        }
    }
}

var cappingPower, cappingTeamPower;
if(object_index == ArenaControlPoint)
{
    reds = 0;
    blues = 0;
    livereds = 0;
    liveblues = 0;
    
    for(i=0; i&lt;ds_list_size(global.players); i+=1)
    {
        player = ds_list_find_value(global.players, i);
        
        if(player.team == TEAM_RED)
        {
            reds += 1;
            if (player.object != -1 and instance_exists(player.object))
                livereds += 1;
        }
        else if (player.team == TEAM_BLUE)
        {
            blues += 1;
            if (player.object != -1 and instance_exists(player.object))
                liveblues += 1;
        }
    }
    var maxCappingPower;
    maxCappingPower = 4;
    cappingPower[TEAM_BLUE] = max(1,reds)/((1-1/maxCappingPower)*livereds + (1/maxCappingPower)*max(1,reds));
    cappingPower[TEAM_RED] = max(1,blues)/((1-1/maxCappingPower)*liveblues + (1/maxCappingPower)*max(1,blues));
}
else
{
    cappingPower[TEAM_RED] = 1;
    cappingPower[TEAM_BLUE] = 1;
}

if (cappingTeam == TEAM_RED or cappingTeam == TEAM_BLUE)
    cappingTeamPower = cappingPower[cappingTeam]
else
    cappingTeamPower = 1;

// If the player stands on the point all the point sounds should be centered for him.
if(myselfOnPoint) {
    soundx = global.myself.object.x;
    soundy = global.myself.object.y;
} else {
    soundx = x;
    soundy = y;
}

if(redPresence&gt;0 and bluePresence&gt;0) {
    // Both teams have some players on the point...
    if(not (oldRedPresence&gt;0 and oldBluePresence&gt;0)) {
        // ...and the defense happened this step, with the cap meter more than half full
        if(bluePresence&gt;0 and oldBluePresence==0 and team==TEAM_BLUE) {
            var isMe;
            isMe = randomBlueCapper.player == global.myself;
            recordEventInLog(2,TEAM_BLUE, randomBlueCapper.player.name, isMe);
            playsound(soundx, soundy, CPDefendedSnd);
        }
        if(redPresence&gt;0 and oldRedPresence==0 and team==TEAM_RED) {
            var isMe;
            isMe = randomRedCapper.player == global.myself;
            recordEventInLog(2,TEAM_RED, randomRedCapper.player.name, isMe);
            playsound(soundx, soundy, CPDefendedSnd);
        }
    }
} else if(redPresence==0 and bluePresence==0) {
    // Nobody on the point, slowly revert the capture
    if(capping&gt;0) capping=max(capping - cappingTeamPower*global.delta_factor, 0);
} else {
    // Some team has players on an undefended point.
    var teamOnPoint, teamOnPointPresence;
    if(redPresence&gt;0) {
        teamOnPoint = TEAM_RED;
        teamOnPointPresence = redPresence;
        teamOnPointOldPresence = oldRedPresence;
        teamOnPointCappers = redCappers;
    } else {
        teamOnPoint = TEAM_BLUE;
        teamOnPointPresence = bluePresence;
        teamOnPointOldPresence = oldBluePresence;
        teamOnPointCappers = blueCappers;
    }
    
    if (teamOnPointPresence == 1)
    {
        // Only an ubercharged player on the point
        // He can't cap, but he will prevent the point from reverting if his team
        // has partially capped it already
        if (teamOnPoint != cappingTeam)
        {
            capping = max(capping - cappingTeamPower*global.delta_factor, 0);
        }
    }
    else
    {
        // One team has cap-able players on an undefended point...
        if(cappingTeam != -1 and teamOnPoint != cappingTeam)
        {
            // ...but the other team has the point partially captured already, so
            // they have to revert first.
            capping=max(capping - (1+teamOnPointCappers*0.5)*cappingTeamPower*global.delta_factor, 0);
        }
        else if(teamOnPoint != team)
        {
            // ...and the point is not partially capped by the enemy team, and we don't own it already.
            // So let's cap!
            
            if(teamOnPointOldPresence&lt;2 or cappingTeam != teamOnPoint or (oldRedPresence&gt;0 and oldBluePresence&gt;0)) {
                // Play the cap start sound if the team just entered the point,
                // OR we just finished reverting the capture from the other team,
                // OR the point was defended last step.
                playsound(soundx, soundy, CPBeginCapSnd);
            }
            cappingTeam = teamOnPoint;
            cappers = teamOnPointCappers;
            if(cappers&lt;=2) {
                capping += cappers * cappingPower[cappingTeam] * global.delta_factor;
            } else {
                capping += (cappers/2+1) * cappingPower[cappingTeam] * global.delta_factor;
            }
        }
    }
}

if(capping &lt;= 0) {
    capping = 0;
    cappingTeam = -1;
} else if global.isHost {
    if floor(capping) == floor(capTime - capTime/4) || floor(capping) == floor(capTime/4) || floor(capping) == floor(capTime/10){
        GameServer.syncTimer = 1;
    } else if capping &gt;= capTime {
        pointCapture(cp);
        if instance_exists(ControlPointHUD) {
            if ControlPointHUD.mode == 1 ControlPointHUD.timer += 5400;
        }
        GameServer.syncTimer = 1; 
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>receiveCompleteMessage(global.serverSocket,4,global.deserializeBuffer);
temp = fct_read_byte(global.deserializeBuffer);
cappingTeam = fct_read_byte(global.deserializeBuffer);
capping = fct_read_ushort(global.deserializeBuffer);
if team != temp {
    pointCapture(cp);
    team = temp;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>fct_write_byte(global.serializeBuffer, team);
fct_write_byte(global.serializeBuffer, cappingTeam);
fct_write_ushort(global.serializeBuffer, round(capping));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alpha=0;
fade=0.05;

if(instance_exists(ArenaControlPoint)) {
    mode=2;     // Arena
    locked=true;
} else if(instance_exists(KothControlPoint)) {
    mode=3;     // King of the Hill
    locked=true;
} else if(instance_exists(KothRedControlPoint) &amp;&amp; instance_exists(KothBlueControlPoint)) {
    mode=4;     // Dual King of the Hill
    locked=true;
}else if(instance_exists(ControlPointSetupGate)) {
    mode=1;     // A/D
    locked=false;
} else {
    mode=0;     // Symmetrical CP
    locked=false;
}
    
global.cp[cp] = id;

team=-1;
redPresence=0;
bluePresence=0;
capping=0;
cappers=0;
cappingTeam=-1;
capTime=300;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if team == -1 sprite_index = ControlPointNeutralS;
else if team == TEAM_RED sprite_index = ControlPointRedS;
else if team == TEAM_BLUE sprite_index = ControlPointBlueS;
draw_sprite(sprite_index,0,x,y);
draw_sprite_ext(sprite_index,1,x,y,1,1,0,c_white,alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
